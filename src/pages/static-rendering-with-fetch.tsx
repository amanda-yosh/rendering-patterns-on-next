import Head from "next/head";
import Image from "next/image";
import Link from "next/link";
import useSWR from "swr";

import VideoWrapper from "@/components/VideoWrapper";
import DogCard from "@/components/DogCard";
import Resume from "@/components/Resume";
import Title from "@/components/Title";
import Alert from "@/components/Alert";

import img2 from '@/assets/static-rendering/static-rendering-with-fetch2.png'
import hehe from '@/assets/static-rendering/hehe.gif'

import pagesStyles from '@/styles/Pages.module.css'
import styles from "@/styles/StaticRendering.module.css";

interface DogData {
    name: string,
    age: number,
    breed: string,
    veterinary_history: {
        vaccines: Array<string>,
        deworming: string,
        castration: boolean
    },
    image: string
};

const fetcher = (url: string) => fetch(url).then((res) => res.json());

function DogCardSkeleton() {
    return (
        <div className={styles.skeleton}>
            <div className={styles.skeletonImage} />
            <div className={styles.skeletonText} />
        </div>
    );
}

export default function StaticRenderingWithFetch() {
    const { data, isLoading } = useSWR("/api/with-fetch", fetcher);

    return (
        <>
            <Head>
                <title>Renderização Estática com Fetch</title>
                <meta name="description" content="Generated by create next app" />
                <meta name="viewport" content="width=device-width, initial-scale=1" />
                <link rel="icon" href="/favicon.ico" />
            </Head>

            <div className={pagesStyles.page}>
                <main className={pagesStyles.main}>
                    <Title borderBlack>
                        Esta é uma página que renderiza de forma estática e faz um fetch do lado do cliente
                    </Title>

                    <div className={styles.dogWrapper}>
                        {isLoading
                            ? Array.from({ length: 4 }).map(
                                (_, index) => <DogCardSkeleton key={index} />)
                            : data.map((dog: DogData) => {
                                return (
                                    <DogCard {...dog} key={dog.image} />
                                )
                            })
                        }
                    </div>


                    <section className={pagesStyles.section}>
                        <p>
                            Acima, você viu um exemplo de uma lista de Doguinhos. Para criar essa listagem foi preciso de uma API que nos forneceu os dados necessários.
                        </p>

                        <div style={{ display: 'flex', alignItems: 'center' }}>
                            <p>
                                Para isto, usamos a <span className={styles.focus}>Renderização Estática com um Fetch do lado do cliente</span>. Este padrão funciona bem quando você quer atualizar dados em cada solicitação.
                            </p>

                            <Image
                                className={styles.logo}
                                src={hehe}
                                alt="Next.js logo"
                                width={60}
                                height={60}
                                priority
                            />
                        </div>

                        <p>
                            <span className={styles.focus}>O HTML é gerado em tempo de build</span> e renderizado com o componente esqueleto, que será substituído pelo componente com os dados da listagem dinâmica após o <span className={styles.focus}>fetch dos dados no lado do cliente</span>.
                            <br />
                            Utilizamos o <Link href="https://swr.vercel.app/pt-BR" style={{ textDecoration: 'underline' }}>SWR</Link> para fazer o fetch dos dados, porque ele possui uma estratégia de invalidação de cache. Primeiro ele retornar os dados do cache (stale) e depois enviar a solicitação de fetch (revalidate), e finalmente retornar com os dados atualizados. Assim, fazemos o fetch para a rota de API personalizada dos Doguinhos.
                            <br />
                            <span className={styles.focus}>Este padrão também é facilmente cacheável através de uma CDN.</span>
                        </p>
                    </section>

                    <Alert>
                        <p>
                            <span className={styles.focus}>INDICADO PARA</span> páginas que contém dados que mudam a cada requisição; e para páginas que contém componentes com placeholder estáveis.
                        </p>
                    </Alert>

                    <section className={pagesStyles.section}>
                        <p>
                            Vamos visualizar o que acontece quando entramos em um site que utiliza a renderização estática com fetch de dados.
                        </p>

                        <VideoWrapper fileName='video2.webm' source="Fonte: https://www.patterns.dev/vanilla/rendering-patterns" />

                        <p>
                            O arquivo HTML pré-gerado é enviado ao cliente quando o usuário solicita a página. O usuário inicialmente vê a UI do esqueleto sem nenhum dado. O cliente busca os dados da rota da API, recebe a resposta e mostra a listagem.
                        </p>
                    </section>

                    <Image
                        className={styles.logo}
                        src={img2}
                        alt="Next.js logo"
                        width={600}
                        height={380}
                        priority
                    />

                    <Resume
                        title='Renderização Estática com Fetch de dados'
                        qualifications={[
                            { name: 'Time To First Byte', score: 'good' },
                            { name: 'First Contentful Paint', score: 'good' },
                            { name: 'Largest Contentful Paint', score: 'warn' },
                            { name: 'Time To Interactive', score: 'good' },
                            { name: 'Cumulative Layout Shift', score: 'warn' },
                            { name: 'First Input Delay', score: 'good' },
                            { name: 'Fast Build Times', score: 'good' },
                            { name: 'Low Server Costs', score: 'warn' },
                            { name: 'Easy Rollbacks', score: 'good' },
                            { name: 'Reliable uptime', score: 'warn' },
                            { name: 'Dynamic Content', score: 'warn' },
                            { name: 'Scalable infraestructure', score: 'warn' },
                        ]}
                    />

                    <section className={pagesStyles.section}>
                        <p>
                            Embora a renderização estática com fetch do lado do cliente nos dê um bom TTFB e FCP, o LCP não é o ideal, pois o &quot;maior conteúdo&quot; só pode ser exibido depois de obtermos os dados das listagens da rota da API.
                            <br />
                            Também há uma forte possibilidade de mudanças de layout, especialmente se o tamanho do esqueleto da UI não corresponder ao conteúdo renderizado eventualmente.
                            <br />
                            Outra desvantagem é que essa abordagem pode resultar em custos de servidor mais altos, já que chamamos a rota da API uma vez por solicitação de página.
                            <br />
                            O Next.js oferece algumas soluções, conforme discutido nas seções a seguir, para melhorar o desempenho do seu aplicativo ao trabalhar com dados dinâmicos.
                        </p>
                    </section>
                </main>
            </div>
        </>
    );
}
