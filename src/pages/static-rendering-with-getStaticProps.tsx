import type { InferGetStaticPropsType, GetStaticProps } from 'next'
import Head from "next/head";
import Link from "next/link";
import Image from "next/image";

import Resume from "@/components/Resume";
import Title from "@/components/Title";
import Alert from "@/components/Alert";
import UserCard from '@/components/UserCard';
import VideoWrapper from '@/components/VideoWrapper';

import img1 from '@/assets/static-rendering/getStaticProps1.png'

import pagesStyles from "@/styles/Pages.module.css";
import styles from "@/styles/StaticRendering.module.css";

type UserProps = {
    avatar_url: string;
    name: string;
    location: string;
    bio: string;
    public_repos: number;
    followers: number;
    following: number;
}

export default function StaticRenderingWithGetStaticProps({ user }: InferGetStaticPropsType<typeof getStaticProps>) {
    return (
        <>
            <Head>
                <title>Renderização Estática com getStaticProps | Static Rendering</title>
                <meta name="description" content="Generated by create next app" />
                <meta name="viewport" content="width=device-width, initial-scale=1" />
                <link rel="icon" href="/favicon.ico" />
            </Head>

            <div className={pagesStyles.page}>
                <main className={pagesStyles.main}>
                    <Title borderBlack>Esta é uma página que renderiza de forma estática com o getStaticProps</Title>

                    <UserCard user={user} />

                    <section className={pagesStyles.section}>
                        <p>
                            O método <Link href='https://nextjs.org/docs/pages/building-your-application/data-fetching/get-static-props' style={{ textDecoration: 'underline' }}>getStaticProps</Link> permite que a página HTML seja pré-renderizada <span className={styles.focus}>no momento do build</span> com os dados retornados pelo método. É uma boa solução caso os dados necessários para renderizar a página estiverem disponíveis no momento do build.
                        </p>

                        <p>
                            Assim, podemos evitar fazer fetchs de dados no cliente. Da mesma forma, um componente esqueleto não é necessário enquanto os dados são carregados, pois a página será renderizada com os dados.
                        </p>
                    </section>

                    <Alert>
                        <p>
                            <span className={styles.focus}>INDICADO PARA</span> páginas que terão os dados disponíveis no momento do build (ex.: CMS); não são específicas do usuário; podem ser cacheadas de forma global.
                        </p>
                    </Alert>

                    <section className={pagesStyles.section}>
                        <VideoWrapper fileName='video3.webm' source="Fonte: https://www.patterns.dev/vanilla/rendering-patterns" />

                        <p>
                            Quando construímos o projeto, o provedor de dados é chamado e os dados retornados são canalizados para o HTML gerado.
                        </p>

                        <VideoWrapper fileName='video4.webm' source="Fonte: https://www.patterns.dev/vanilla/rendering-patterns" />

                        <p>
                            Quando um usuário solicita a página, o processo é similar à renderização estática simples. A resposta é armazenada em cache e renderizada na tela, e o navegador busca os pacotes JavaScript necessários para hidratar a página.
                        </p>
                    </section>

                    <Image
                        src={img1}
                        alt=""
                        width={600}
                        height={380}
                        priority
                    />

                    <section className={pagesStyles.section}>
                        <p>
                            Da perspectiva do cliente, o network e a main thread funcionam de forma idêntica à renderização estática simples, o que nos dá uma performance igualmente boa.
                        </p>
                    </section>

                    <Resume
                        title='Renderização Estática'
                        qualifications={[
                            { name: 'Time To First Byte', score: 'good' },
                            { name: 'First Contentful Paint', score: 'good' },
                            { name: 'Largest Contentful Paint', score: 'good' },
                            { name: 'Time To Interactive', score: 'good' },
                            { name: 'Cumulative Layout Shift', score: 'good' },
                            { name: 'First Input Delay', score: 'good' },
                            { name: 'Fast Build Times', score: 'warn' },
                            { name: 'Low Server Costs', score: 'good' },
                            { name: 'Easy Rollbacks', score: 'good' },
                            { name: 'Reliable uptime', score: 'good' },
                            { name: 'Dynamic Content', score: 'warn' },
                            { name: 'Scalable infraestructure', score: 'good' },
                        ]}
                    />

                    <section className={pagesStyles.section}>
                        <p>
                            Para sites com centenas de páginas construídas estaticamente (ex.: blogs), chamar o método getStaticProps repetidamente pode resultar em longos tempos de build. Se você estiver usando uma API externa, poderá atingir o limite de solicitações ou exceder o $.
                            <br />
                            O método não é adequado para atualizações frequentes de dados, o que significa ter que reconstruir e reimplantar o site com frequência.
                        </p>
                    </section>
                </main>
            </div>
        </>
    );
}

export const getStaticProps = (async (context) => {
    const amandaGithubUser = await fetch('https://api.github.com/users/amanda-yosh')
    const user = await amandaGithubUser.json()

    return {
        props: {
            user: {
                avatar_url: user.avatar_url,
                name: user.name,
                location: user.location,
                bio: user.bio,
                public_repos: user.public_repos,
                followers: user.followers,
                following: user.following,
            }
        }
    }
}) satisfies GetStaticProps<{
    user: UserProps
}>
